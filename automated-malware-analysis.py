import os
import sys
import docker
import requests
import hashlib
import time
import io
import logging
import uuid
import json
import tempfile
import base64
import datetime
from dotenv import load_dotenv
from OTXv2 import OTXv2
from OTXv2 import IndicatorTypes
from rich.console import Console
from rich.table import Table
from rich.panel import Panel

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Load environment variables
load_dotenv()

# API keys
VIRUSTOTAL_API_KEY = os.getenv('VIRUSTOTAL_API_KEY')
ABUSEIPDB_API_KEY = os.getenv('ABUSEIPDB_API_KEY')
ALIENVAULT_OTX_API_KEY = os.getenv('ALIENVAULT_OTX_API_KEY')

# Initialize Rich console
console = Console()

# Create a unique UUID for this run
RUN_UUID = str(uuid.uuid4())

def check_api_keys():
    missing_keys = []
    if not VIRUSTOTAL_API_KEY:
        missing_keys.append("VIRUSTOTAL_API_KEY")
    if not ABUSEIPDB_API_KEY:
        missing_keys.append("ABUSEIPDB_API_KEY")
    if not ALIENVAULT_OTX_API_KEY:
        missing_keys.append("ALIENVAULT_OTX_API_KEY")
    
    if missing_keys:
        console.print(f"[bold red]Error: The following API keys are missing: {', '.join(missing_keys)}[/bold red]")
        console.print("Please add them to your .env file.")
        sys.exit(1)

def get_file_hash(file_path):
    """Calculate the SHA-256 hash of a file."""
    try:
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    except IOError as e:
        logging.error(f"Error reading file {file_path}: {str(e)}")
        return None

def analyze_with_virustotal(input_data):
    """Analyze the input data with VirusTotal API and return results."""
    if not VIRUSTOTAL_API_KEY:
        console.print("[yellow]VirusTotal API key not found. Skipping VirusTotal analysis.[/yellow]")
        return None
    try:
        base_url = "https://www.virustotal.com/api/v3/"
        headers = {"x-apikey": VIRUSTOTAL_API_KEY}

        if os.path.isfile(input_data):
            file_hash = get_file_hash(input_data)
            if not file_hash:
                return None
            endpoint = f"files/{file_hash}"
        elif input_data.startswith(("http://", "https://")):
            endpoint = f"urls/{requests.utils.quote(input_data, safe='')}"
        elif all(c in '0123456789abcdefABCDEF' for c in input_data) and len(input_data) in [32, 40, 64]:
            endpoint = f"files/{input_data}"
        else:
            endpoint = f"ip_addresses/{input_data}"

        response = requests.get(base_url + endpoint, headers=headers)
        response.raise_for_status()
        
        if response.status_code == 200:
            result = response.json()
            return result
        else:
            console.print(f"[bold red]Error in VirusTotal API call: {response.status_code} - {response.text}[/bold red]")
            return None
    except requests.RequestException as e:
        if e.response is not None and e.response.status_code == 401:
            console.print("[bold red]VirusTotal API authentication failed. Please check your API key.[/bold red]")
        else:
            console.print(f"[bold red]Error in VirusTotal API call: {str(e)}[/bold red]")
        return None

def analyze_with_abuseipdb(ip_address):
    """Analyze an IP address with AbuseIPDB and return results."""
    if not ABUSEIPDB_API_KEY:
        console.print("[yellow]AbuseIPDB API key not found. Skipping AbuseIPDB analysis.[/yellow]")
        return None
    try:
        url = 'https://api.abuseipdb.com/api/v2/check'
        querystring = {
            'ipAddress': ip_address,
            'maxAgeInDays': '90'
        }
        headers = {
            'Accept': 'application/json',
            'Key': ABUSEIPDB_API_KEY
        }
        response = requests.get(url, headers=headers, params=querystring)
        response.raise_for_status()
        
        if response.status_code == 200:
            result = response.json()
            return result
        else:
            console.print(f"[bold red]Error in AbuseIPDB API call: {response.status_code} - {response.text}[/bold red]")
            return None
    except requests.RequestException as e:
        if e.response is not None and e.response.status_code == 401:
            console.print("[bold red]AbuseIPDB API authentication failed. Please check your API key.[/bold red]")
        else:
            console.print(f"[bold red]Error in AbuseIPDB API call: {str(e)}[/bold red]")
        return None

def analyze_with_alienvault_otx(indicator):
    """Analyze an indicator with AlienVault OTX and return results."""
    if not ALIENVAULT_OTX_API_KEY:
        console.print("[yellow]AlienVault OTX API key not found. Skipping AlienVault OTX analysis.[/yellow]")
        return None
    try:
        otx = OTXv2(ALIENVAULT_OTX_API_KEY)
        
        if os.path.isfile(indicator):
            indicator_type = IndicatorTypes.FILE_HASH_SHA256
            indicator = get_file_hash(indicator)
            if not indicator:
                return None
        elif indicator.startswith(("http://", "https://")):
            indicator_type = IndicatorTypes.URL
        elif all(c in '0123456789abcdefABCDEF' for c in indicator) and len(indicator) in [32, 40, 64]:
            indicator_type = IndicatorTypes.FILE_HASH_SHA256
        else:
            indicator_type = IndicatorTypes.IPv4

        result = otx.get_indicator_details_full(indicator_type, indicator)
        return result
    except Exception as e:
        console.print(f"[bold red]Error in AlienVault OTX analysis: {str(e)}[/bold red]")
        return None

def check_docker_status():
    """Check if Docker is running and accessible."""
    try:
        client = docker.from_env()
        client.ping()
        return True
    except docker.errors.DockerException:
        return False

def create_sandbox_container(tag):
    """Create and start a lightweight Docker container for sandbox analysis with a non-root user."""
    try:
        client = docker.from_env()
        
        dockerfile_content = '''
        FROM alpine:latest
        RUN apk add --no-cache python3 file
        RUN adduser -D sandboxuser
        USER sandboxuser
        WORKDIR /home/sandboxuser
        RUN mkdir -p /home/sandboxuser/samples /home/sandboxuser/results/VirusTotal /home/sandboxuser/results/AbuseIPDB /home/sandboxuser/results/AlienVault_OTX
        '''
        
        image, _ = client.images.build(fileobj=io.BytesIO(dockerfile_content.encode('utf-8')), tag=tag)
        
        container = client.containers.run(
            tag,
            name=f"malware_sandbox_{tag.split(':')[1]}",
            detach=True,
            command="tail -f /dev/null",
            network_mode="none",
            cap_drop=["ALL"],
            security_opt=["no-new-privileges"],
            mem_limit="512m"
        )
        
        container.reload()
        if container.status != 'running':
            raise docker.errors.ContainerError(container, container.status, "Container failed to start")
        
        return container, client
    except docker.errors.DockerException as e:
        console.print(f"[bold red]Error creating Docker container: {str(e)}[/bold red]")
        return None, None


def save_results_to_container(container, results, tool_name, input_data):
    """Save analysis results to a file in the sandbox container."""
    if not results:
        console.print(f"[yellow]No results to save for {tool_name}[/yellow]")
        return

    filename = f"{input_data.replace('/', '_')}_{tool_name.lower()}_results.json"
    dir_path = f"/home/sandboxuser/results/{tool_name}"
    container_path = f"{dir_path}/{filename}"
    
    # Ensure the directory exists
    mkdir_cmd = f"mkdir -p {dir_path}"
    mkdir_result = container.exec_run(f"/bin/sh -c '{mkdir_cmd}'")
    if mkdir_result.exit_code != 0:
        console.print(f"[bold red]Error creating directory {dir_path}: {mkdir_result.output.decode('utf-8')}[/bold red]")
        return

    # Convert results to JSON string and encode in base64
    json_str = json.dumps(results, indent=4)
    base64_str = base64.b64encode(json_str.encode()).decode()
    
    # Write content to the file in chunks
    chunk_size = 1000  # Adjust this value if needed
    for i in range(0, len(base64_str), chunk_size):
        chunk = base64_str[i:i+chunk_size]
        if i == 0:
            write_cmd = f"echo '{chunk}' | base64 -d > {container_path}"
        else:
            write_cmd = f"echo '{chunk}' | base64 -d >> {container_path}"
        
        write_result = container.exec_run(f"/bin/sh -c '{write_cmd}'")
        if write_result.exit_code != 0:
            console.print(f"[bold red]Error writing chunk to file: {write_result.output.decode('utf-8')}[/bold red]")
            return

    console.print(f"[green]{tool_name} results saved to {container_path} in the sandbox container[/green]")
        
    # Verify file content
    verify_cmd = f"cat {container_path}"
    verify_result = container.exec_run(f"/bin/sh -c '{verify_cmd}'")
    if verify_result.exit_code == 0:
        console.print(f"[green]Successfully verified content of {container_path}[/green]")
    else:
        console.print(f"[bold red]Error verifying content of {container_path}: {verify_result.output.decode('utf-8')}[/bold red]")

def perform_sandbox_analysis(container, input_data, vt_results, abuseipdb_results, otx_results):
    try:
        console.print("[cyan]Running sandbox analysis...[/cyan]")
        
        # Copy the input file to the container if it's a file
        if os.path.isfile(input_data):
            container.exec_run("mkdir -p /home/sandboxuser/input")
            with open(input_data, 'rb') as file:
                container.put_archive("/home/sandboxuser/input", file.read())
            analysis_command = f"file /home/sandboxuser/input/{os.path.basename(input_data)} > /home/sandboxuser/results/analysis_report.txt"
        else:
            analysis_command = f"echo 'Analysis of {input_data}' > /home/sandboxuser/results/analysis_report.txt"
        
        # Run commands and capture their output
        commands = [
            analysis_command,
            "ls -lR /home/sandboxuser >> /home/sandboxuser/results/analysis_report.txt",
            "ps aux >> /home/sandboxuser/results/analysis_report.txt"
        ]
        
        for cmd in commands:
            result = container.exec_run(f"/bin/sh -c '{cmd}'")
            if result.exit_code != 0:
                console.print(f"[yellow]Command failed: {cmd}[/yellow]")
                console.print(f"Exit code: {result.exit_code}")
                console.print(f"Output: {result.output.decode('utf-8')}")
        
        # Save results from other tools
        save_results_to_container(container, vt_results, "VirusTotal", input_data)
        save_results_to_container(container, abuseipdb_results, "AbuseIPDB", input_data)
        save_results_to_container(container, otx_results, "AlienVault_OTX", input_data)
        
        # Try to read the results file
        result = container.exec_run("/bin/sh -c 'cat /home/sandboxuser/results/analysis_report.txt'")
        if result.exit_code == 0:
            return result.output.decode('utf-8')
        else:
            console.print("[yellow]Failed to read analysis report. Checking container logs...[/yellow]")
            logs = container.logs().decode('utf-8')
            return f"Sandbox analysis completed, but failed to read results. Container logs:\n{logs}"
    except Exception as e:
        console.print(f"[bold red]Error performing sandbox analysis: {str(e)}[/bold red]")
        return f"Error performing sandbox analysis: {str(e)}"

def retrieve_results(container, output_dir):
    """Retrieve results from the sandbox container."""
    try:
        os.makedirs(output_dir, exist_ok=True)
        
        # Create a tarstream of the results directory
        stream, _ = container.get_archive('/home/sandboxuser/results')
        
        # Write the tarstream to a file
        with open(os.path.join(output_dir, 'results.tar'), 'wb') as f:
            for chunk in stream:
                f.write(chunk)
        
        console.print(f"[green]Results retrieved and saved to {output_dir}[/green]")
    except docker.errors.APIError as e:
        console.print(f"[bold red]Error retrieving results: {str(e)}[/bold red]")

def cleanup(client, tag):
    """Stop and remove all containers and images created by this script."""
    console.print("Cleaning up Docker resources...")
    try:
        containers = client.containers.list(all=True, filters={"name": f"malware_sandbox_{tag.split(':')[1]}"})
        for container in containers:
            container.stop()
            container.remove(force=True)
            console.print(f"Removed container: {container.name}")

        images = client.images.list(filters={"reference": tag})
        for image in images:
            client.images.remove(image.id, force=True)
            console.print(f"Removed image: {image.id}")

        console.print("[green]All Docker resources have been cleaned up.[/green]")
    except docker.errors.APIError as e:
        console.print(f"[bold red]Error cleaning up Docker resources: {str(e)}[/bold red]")

def interact_with_files(container):
    """Interact with files in the sandbox container."""
    current_path = "/home/sandboxuser"
    
    def exec_command(cmd):
        result = container.exec_run(f"/bin/sh -c '{cmd}'")
        return result.exit_code, result.output.decode('utf-8', errors='replace')

    def get_file_type(path):
        exit_code, output = exec_command(f"[ -d '{path}' ] && echo 'DIR' || ([ -f '{path}' ] && echo 'FILE' || echo 'INVALID')")
        return output.strip() if exit_code == 0 else 'INVALID'

    def find_file(filename, search_path):
        exit_code, output = exec_command(f"find {search_path} -name '{filename}' -type f")
        if exit_code == 0 and output.strip():
            return output.strip().split('\n')[0]  # Return the first match
        return None

    def view_file_content(filename):
        exit_code, output = exec_command(f"cat '{filename}'")
        if exit_code == 0:
            console.print(f"[green]Contents of file {filename}:[/green]")
            if output.strip():
                console.print(output)
            else:
                console.print("[yellow]The file appears to be empty.[/yellow]")
        else:
            console.print(f"[bold red]Error reading file: {output}[/bold red]")

    while True:
        console.print(f"\n[bold cyan]Current path: {current_path}[/bold cyan]")
        console.print("\n[bold cyan]File Interaction Menu:[/bold cyan]")
        console.print("1. List files in current directory")
        console.print("2. Change directory")
        console.print("3. View file content")
        console.print("4. Execute a command")
        console.print("5. Exit interaction")
        
        choice = console.input("Enter your choice (1-5): ")
        
        if choice == '1':
            exit_code, output = exec_command(f"ls -la {current_path}")
            if exit_code == 0:
                console.print(output)
            else:
                console.print(f"[bold red]Error listing files: {output}[/bold red]")

        elif choice == '2':
            new_path = console.input("Enter the new path (relative or absolute): ").strip()
            if new_path.startswith('cd '):
                new_path = new_path[3:].strip()
            if not new_path.startswith('/'):
                new_path = os.path.normpath(os.path.join(current_path, new_path))
            file_type = get_file_type(new_path)
            if file_type == 'DIR':
                current_path = new_path
                console.print(f"[green]Changed directory to: {current_path}[/green]")
            else:
                console.print(f"[bold red]Invalid directory: {new_path}[/bold red]")

        elif choice == '3':
            filename = console.input("Enter the filename or path to view: ").strip()
            if not filename.startswith('/'):
                full_path = os.path.join(current_path, filename)
                if get_file_type(full_path) == 'INVALID':
                    found_path = find_file(filename, current_path)
                    if found_path:
                        full_path = found_path
                        console.print(f"[yellow]File found at: {full_path}[/yellow]")
                    else:
                        console.print(f"[bold red]File not found: {filename}[/bold red]")
                        continue
            else:
                full_path = filename

            file_type = get_file_type(full_path)
            if file_type == 'DIR':
                exit_code, output = exec_command(f"ls -la '{full_path}'")
                if exit_code == 0:
                    console.print(f"[green]Contents of directory {full_path}:[/green]")
                    console.print(output)
                else:
                    console.print(f"[bold red]Error listing directory: {output}[/bold red]")
            elif file_type == 'FILE':
                view_file_content(full_path)
            else:
                console.print(f"[bold red]Invalid file or directory: {full_path}[/bold red]")

        elif choice == '4':
            command = console.input("Enter the command to execute: ")
            exit_code, output = exec_command(f"cd {current_path} && {command}")
            console.print(f"Command executed with exit code: {exit_code}")
            console.print(output)

        elif choice == '5':
            break
        else:
            console.print("[bold red]Invalid choice. Please try again.[/bold red]")

def get_analysis_choices():
    """Prompt the user to select which analyses to run."""
    console.print("\n[bold cyan]Select the analyses you want to run:[/bold cyan]")
    console.print("1. VirusTotal")
    console.print("2. AbuseIPDB (for IP addresses only)")
    console.print("3. AlienVault OTX")
    console.print("4. Sandbox Analysis")
    console.print("5. All of the above")
    console.print("6. Interact with sandbox files")
    
    while True:
        try:
            choices = console.input("Enter the numbers of your choices (comma-separated, e.g., 1,3,4,6): ")
            choices = [choice.strip() for choice in choices.split(',')]
            if set(choices).issubset({'1', '2', '3', '4', '5', '6'}):
                return choices
            else:
                console.print("[bold red]Invalid input. Please enter numbers between 1 and 6.[/bold red]")
        except Exception as e:
            logging.error(f"Error in user input: {str(e)}")
            console.print("[bold red]An error occurred. Please try again.[/bold red]")

def format_results(title, data):
    if not data:
        console.print(f"[bold red]{title} analysis failed or returned no results.[/bold red]")
        return

    console.print(Panel(f"[bold blue]{title} Results[/bold blue]", expand=False))

    if isinstance(data, dict):
        table = Table(show_header=True, header_style="bold magenta")
        table.add_column("Key", style="dim", width=20)
        table.add_column("Value")

        for key, value in data.items():
            if isinstance(value, dict):
                table.add_row(key, str(value))
            elif isinstance(value, list):
                table.add_row(key, ", ".join(map(str, value)))
            else:
                table.add_row(key, str(value))

        console.print(table)
    else:
        console.print(data)

def analyze_input(input_data, container, analysis_choices):
    """Analyze a single input using selected threat intelligence sources and sandbox."""
    console.print(f"\n[bold green]Analyzing: {input_data}[/bold green]")

    vt_results = abuseipdb_results = otx_results = None

    if '5' in analysis_choices:
        analysis_choices = ['1', '2', '3', '4', '6']

    if '1' in analysis_choices:
        console.print("[bold cyan]Performing VirusTotal analysis...[/bold cyan]")
        vt_results = analyze_with_virustotal(input_data)
        format_results("VirusTotal", vt_results)

    if '2' in analysis_choices:
        if not os.path.isfile(input_data) and not input_data.startswith(("http://", "https://")):
            console.print("[bold cyan]\nPerforming AbuseIPDB analysis...[/bold cyan]")
            abuseipdb_results = analyze_with_abuseipdb(input_data)
            format_results("AbuseIPDB", abuseipdb_results)
        else:
            console.print("[yellow]\nAbuseIPDB analysis skipped (not applicable for this input type)[/yellow]")

    if '3' in analysis_choices:
        console.print("[bold cyan]\nPerforming AlienVault OTX analysis...[/bold cyan]")
        otx_results = analyze_with_alienvault_otx(input_data)
        format_results("AlienVault OTX", otx_results)

    if '4' in analysis_choices:
        console.print("[bold cyan]\nPerforming sandbox analysis...[/bold cyan]")
        sandbox_results = perform_sandbox_analysis(container, input_data, vt_results, abuseipdb_results, otx_results)
        format_results("Sandbox Analysis", sandbox_results)

    if '6' in analysis_choices:
        interact_with_files(container)

def main():
    check_api_keys()
    
    if len(sys.argv) < 2:
        console.print("[bold red]Usage: python script.py <file_path|url|ip|hash> [additional_inputs...][/bold red]")
        sys.exit(1)

    inputs = sys.argv[1:]

    if not check_docker_status():
        console.print("[bold red]Error: Docker is not running or not accessible.[/bold red]")
        console.print("Please ensure Docker is installed and running on your system.")
        sys.exit(1)

    tag = f"sandbox:{RUN_UUID[:8]}"
    container, client = None, None

    try:
        console.print("[bold cyan]Preparing sandbox environment...[/bold cyan]")
        container, client = create_sandbox_container(tag)
        if not container:
            console.print("[bold red]Failed to create sandbox environment. Exiting.[/bold red]")
            sys.exit(1)

        analysis_choices = get_analysis_choices()
        
        for input_data in inputs:
            analyze_input(input_data, container, analysis_choices)

        while True:
            more_analysis = console.input("\nDo you want to analyze more inputs or interact with files? (yes/no): ").lower()
            if more_analysis != 'yes':
                break

            action = console.input("Enter 'analyze' to analyze a new input or 'interact' to interact with files: ").lower()
            if action == 'analyze':
                new_input = console.input("Enter the new file path, URL, IP, or hash to analyze: ")
                new_choices = console.input("Do you want to use the same analysis options? (yes/no): ").lower()
                if new_choices != 'yes':
                    analysis_choices = get_analysis_choices()
                analyze_input(new_input, container, analysis_choices)
            elif action == 'interact':
                interact_with_files(container)
            else:
                console.print("[bold red]Invalid action. Please try again.[/bold red]")

        # Retrieve results from the sandbox container
        output_dir = f"analysis_results_{RUN_UUID}"
        retrieve_results(container, output_dir)

    except KeyboardInterrupt:
        console.print("\n[bold yellow]Operation cancelled by user. Cleaning up...[/bold yellow]")
    except Exception as e:
        console.print(f"[bold red]An unexpected error occurred: {str(e)}[/bold red]")
        logging.exception("Unexpected error")
    finally:
        if container and client:
            cleanup(client, tag)

    console.print("[bold green]Analysis complete. All Docker resources have been destroyed.[/bold green]")
    console.print(f"[bold green]Results saved in the '{output_dir}' directory.[/bold green]")

if __name__ == "__main__":
    main()
